/*
    1.在 Rust 中使用 mod 来标记一个模块,模块支持嵌套,模块还可以保存一些定义的其他项，比如结构体、枚举、常量、特性、或者函数。
    2.Rust 中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的。
        父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用他们父模块中的项。
        这是因为子模块封装并隐藏了他们的实现详情，但是子模块可以看到他们定义的上下文。
    3.使用 pub 关键字可以将模块和模块内的结构体、枚举、常量、特性、或者函数暴露给外部使用
    4.路径有两种方式:
        绝对路径（absolute path）从 crate 根开始，以 crate 名或者字面值 crate 开头。(一般建议使用绝对路径)
        相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。
    5.使用 super 关键字来获取从父模块开始的相对路径。前提是获取的模块及其结构体、枚举、常量、特性、或者函数是经过 pub 修饰的
    6.一个结构体定义的前面使用了 pub ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的。我们可以根据情况决定每个字段是否公有。
        与之相反，如果我们将枚举设为公有，则它的所有成员都将变为公有。我们只需要在 enum 关键字前面加上 pub
    7.使用 use 关键字将路径一次性引入作用域，然后调用该路径中的项，就如同它们是本地项一样。
    8.使用 as 将引入的路径指定一个新的本地名称或者别名
    9.使用 use 关键字，将某个名称导入当前作用域后，这个名称在此作用域中就可以使用了，但它对此作用域之外还是私有的。
        如果想让其他人调用我们的代码时，也能够正常使用这个名称，就好像它本来就在当前作用域一样，那我们可以将 pub 和 use 合起来使用。
        这种技术被称为 “重导出（re-exporting）”：我们不仅将一个名称导入了当前作用域，还允许别人把它导入他们自己的作用域。
    10.可以使用嵌套路径将相同的项在一行中引入作用域。这么做需要指定路径的相同部分，接着是两个冒号，接着是大括号中的各自不同的路径部分
    11.如果希望将一个路径下 所有 公有项引入作用域，可以指定路径后跟 * glob 运算符
*/
pub fn test() {
    // 相对路径
    front_of_house::hosting::add_to_waitlist();

    // 绝对路径
    crate::front_of_house::hosting::add_to_waitlist();
}

mod front_of_house;

pub use crate::front_of_house::hosting;

use std::fmt::Result;
use std::io::Result as IoResult;
pub fn test2() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
fn function1() -> Result {
    // --snip--
    Ok(())
}

fn function2() -> IoResult<()> {
    // --snip--
    Ok(())
}
