/*
   所有权规则：
   1、Rust 中的每一个值都有一个被称为其 所有者（owner）的变量
   2、值在任一时刻有且只有一个所有者
   3、当所有者（变量）离开作用域，这个值将被丢弃
*/
fn main() {
    // 变量的声明周期从它的声明开始，到它所在的作用域结束而结束
    let str = "hello";
    // 声明一个变量str2存储在堆上分配的未知大小文本对象的地址
    let mut str2 = String::from("hello2");

    // 使用函数对字符串str2实现字符串追加
    str2.push_str(",uqingu");

    println!("Hello, world!{}", str);
    println!("Hello, world!{}", str2);

    /*
        Rust对内存的管理：
        1、内存在拥有它的变量离开作用域后就被自动释放。
        2、当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop，在这里 String 的作者可以放置释放内存的代码。
        3、Rust 在结尾的 } 处自动调用 drop 函数。

        String 类型的变量由三部分组成一个指向存放字符串内容内存的指针，一个长度，和一个容量
        当我们声明一个变量接收 String 类型的数据时，变量会存储在栈上，真正的字符串的内容则存储在堆空间
    */

    let s1 = String::from("uqingu");
    let tup: (u8, bool, char, f64) = (2, true, '🎃', 1.22);
    test_tup(&tup);
    let len = calculate_length(&s1);
    println!("字符串的长度为:{}", len);

    let months = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    ];
    test_array(&months);
    let s2 = s1;
    // s1赋值给s2的操作在Rust中称之为移动，在产生移动操作之后，s1变量将会是一个无效的引用
    // println!("{}",s1);

    println!("{}", s2);

    // Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制可以被认为对运行时性能影响较小。
    // 如果我们 确实 需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的通用函数
    let s3 = s2.clone();
    println!("{}", s2);
    println!("{}", s3);

    /*
        Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（。
        如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。
        Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。
        如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。
        实现了 Copy trait 的类型
        1、所有整数类型，比如 u32。
        2、布尔类型，bool，它的值是 true 和 false。
        3、所有浮点数类型，比如 f64。
        4、字符类型，char。
        5、元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。
    */

    // 将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。
    // 返回值也可以转移所有权。

    // 变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。
    // 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。
}

/*
    引用:引用（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。
        与指针不同，引用确保指向某个特定类型的有效值。 
        正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。
        一个引用的作用域从声明的地方开始一直持续到最后一次使用为止


    可变引用:使用 mut 关键字实现可变引用,可变引用有一个很大的限制：在同一时间只能有一个对某一特定数据的可变引用。
        防止同一时间对同一数据进行多个可变引用的限制允许可变性，不过是以一种受限制的方式允许。
        这个限制的好处是 Rust 可以在编译时就避免数据竞争。
        数据竞争（data race）类似于竞态条件，它可由这三个行为造成：
            1、两个或更多指针同时访问同一数据。
            2、至少有一个指针被用来写入数据。
            3、没有同步数据访问的机制。
        数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！
        不能在拥有不可变引用的同时拥有可变引用

    悬垂引用:在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个悬垂指针,所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。
    相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。

    在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。
    引用必须总是有效的。
*/
// 对基本数据类型进行引用
fn calculate_length(s: &String) -> usize {
    s.len()
}

// 对元组类型进行引用
fn test_tup(tup: &(u8, bool, char, f64)) {
    println!("{}", tup.0);
    println!("{}", tup.1);
    println!("{}", tup.2);
    println!("{}", tup.3);
}

// 对数组类型进行引用
fn test_array(arr: &[&str; 12]) {
    // 使用迭代器和 for...in 语句进行遍历
    for val in arr.iter() {
        println!("value is :{}", val);
    }
}
