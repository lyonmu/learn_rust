/*
   所有权规则：
   1、Rust 中的每一个值都有一个被称为其 所有者（owner）的变量
   2、值在任一时刻有且只有一个所有者
   3、当所有者（变量）离开作用域，这个值将被丢弃
*/
fn main() {
    // 变量的声明周期从它的声明开始，到它所在的作用域结束而结束
    let str = "hello";
    // 声明一个变量str2存储在堆上分配的未知大小文本对象的地址
    let mut str2 = String::from("hello2");

    // 使用函数对字符串str2实现字符串追加
    str2.push_str(",uqingu");

    println!("Hello, world!{}", str);
    println!("Hello, world!{}", str2);

    /*
        Rust对内存的管理：
        1、内存在拥有它的变量离开作用域后就被自动释放。
        2、当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop，在这里 String 的作者可以放置释放内存的代码。
        3、Rust 在结尾的 } 处自动调用 drop 函数。

        String 类型的变量由三部分组成一个指向存放字符串内容内存的指针，一个长度，和一个容量
        当我们声明一个变量接收 String 类型的数据时，变量会存储在栈上，真正的字符串的内容则存储在堆空间
    */

    let s1 = String::from("uqingu");
    let s2 = s1;
    // s1赋值给s2的操作在Rust中称之为移动，在产生移动操作之后，s1变量将会是一个无效的引用
    // println!("{}",s1);

    println!("{}", s2);

    // Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制可以被认为对运行时性能影响较小。
    // 如果我们 确实 需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的通用函数
    let s3 = s2.clone();
    println!("{}", s2);
    println!("{}", s3);

    /*
        Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（。
        如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。
        Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。
        如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。
        实现了 Copy trait 的类型
        1、所有整数类型，比如 u32。
        2、布尔类型，bool，它的值是 true 和 false。
        3、所有浮点数类型，比如 f64。
        4、字符类型，char。
        5、元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。
    */

    // 将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。
    // 返回值也可以转移所有权。

    // 变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。
    // 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。
}
